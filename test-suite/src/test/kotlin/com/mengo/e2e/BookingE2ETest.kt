package com.mengo.e2e

import com.mengo.api.booking.model.BookingProduct
import com.mengo.api.booking.model.CreateBookingRequest
import com.mengo.architecture.test.infrastructure.MengoEventStoreAudit
import com.mengo.architecture.test.infrastructure.MengoEventStoreAudit.assertHasEventType
import com.mengo.architecture.test.infrastructure.MengoEventStoreAudit.assertVersionsAreStrictlyIncreasing
import com.mengo.e2e.clients.BookingFeignClient
import com.mengo.e2e.infrastructure.AbstractServicesE2ETest
import com.mengo.payload.booking.BookingCancelledPayload
import com.mengo.payload.booking.BookingConfirmedPayload
import feign.Feign
import feign.jackson.JacksonDecoder
import feign.jackson.JacksonEncoder
import org.awaitility.Awaitility
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertNotNull
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.springframework.cloud.openfeign.support.SpringMvcContract
import java.time.Duration
import java.util.UUID

class BookingE2ETest : AbstractServicesE2ETest() {
    @BeforeEach
    fun resetSystemState() {
        MengoEventStoreAudit.cleanTable(bookingPostgres, "booking", "booking_events")
        MengoEventStoreAudit.cleanTable(orchestratorPostgres, "orchestrator", "orchestrator_events")
        MengoEventStoreAudit.cleanTable(paymentPostgres, "payment", "payment_events")
    }

    @Test
    fun `booking completed E2E`() {
        // given
        val successHeaders = mapOf("x-forced-payment-outcome" to "SUCCESS")
        val bookingClient = createBookingClient(successHeaders)
        val productId = UUID.fromString("22222222-2222-2222-2222-222222222222")

        val createRequest =
            CreateBookingRequest()
                .userId(UUID.randomUUID())
                .products(
                    listOf(
                        BookingProduct()
                            .productId(productId)
                            .quantity(2),
                    ),
                )

        // when
        val response = bookingClient.bookingsPost(createRequest)

        assertNotNull(response, "Booking response should not be null")
        assertNotNull(response.bookingId, "Booking ID should be generated by the service")
        assertEquals("CREATED", response.status.toString(), "Booking should start in CREATED state")

        // then
        Awaitility.await().atMost(Duration.ofSeconds(15)).untilAsserted {
            val bookingEvents = MengoEventStoreAudit.fetchEvents(bookingPostgres, "booking", "booking_events")
            bookingEvents.assertHasEventType("BookingCreatedEvent")
            bookingEvents.assertHasEventType("BookingConfirmedEvent")
            bookingEvents.assertVersionsAreStrictlyIncreasing()

            val orchestratorEvents = MengoEventStoreAudit.fetchEvents(orchestratorPostgres, "orchestrator", "orchestrator_events")
            orchestratorEvents.assertHasEventType("Created")
            orchestratorEvents.assertHasEventType("ProductReserved")
            orchestratorEvents.assertHasEventType("PaymentCompleted")
            orchestratorEvents.assertVersionsAreStrictlyIncreasing()

            val productEvents = MengoEventStoreAudit.fetchEvents(productPostgres, "product", "product_events", productId)
            productEvents.assertHasEventType("ProductReservedEvent")
            productEvents.assertVersionsAreStrictlyIncreasing()

            val paymentEvents = MengoEventStoreAudit.fetchEvents(paymentPostgres, "payment", "payment_events")
            paymentEvents.assertHasEventType("Initiated")
            paymentEvents.assertHasEventType("Completed")
            paymentEvents.assertVersionsAreStrictlyIncreasing()
        }

        createKafkaClient().consumeAndAssert<BookingConfirmedPayload>("booking.completed") { msg ->
            assertNotNull(msg, "Expected a record in booking.completed topic")
            assertEquals(response.bookingId.toString(), msg.key())
        }
    }

    @Test
    fun `booking failed E2E - payment regression`() {
        // given
        val successHeaders = mapOf("x-forced-payment-outcome" to "FAILURE")
        val bookingClient = createBookingClient(successHeaders)
        val productId = UUID.fromString("22222222-2222-2222-2222-222222222222")

        val createRequest =
            CreateBookingRequest()
                .userId(UUID.randomUUID())
                .products(
                    listOf(
                        BookingProduct()
                            .productId(productId)
                            .quantity(2),
                    ),
                )

        // when
        val response = bookingClient.bookingsPost(createRequest)

        assertNotNull(response, "Booking response should not be null")
        assertNotNull(response.bookingId, "Booking ID should be generated by the service")
        assertEquals("CREATED", response.status.toString(), "Booking should start in CREATED state")

        // then
        Awaitility.await().atMost(Duration.ofSeconds(15)).untilAsserted {
            val bookingEvents = MengoEventStoreAudit.fetchEvents(bookingPostgres, "booking", "booking_events")
            bookingEvents.assertHasEventType("BookingCreatedEvent")
            bookingEvents.assertHasEventType("BookingFailedEvent")
            bookingEvents.assertVersionsAreStrictlyIncreasing()

            val orchestratorEvents = MengoEventStoreAudit.fetchEvents(orchestratorPostgres, "orchestrator", "orchestrator_events")
            orchestratorEvents.assertHasEventType("Created")
            orchestratorEvents.assertHasEventType("ProductReserved")
            orchestratorEvents.assertHasEventType("PaymentFailed")
            orchestratorEvents.assertVersionsAreStrictlyIncreasing()

            val productEvents = MengoEventStoreAudit.fetchEvents(productPostgres, "product", "product_events", productId)
            productEvents.assertHasEventType("ProductReservedEvent")
            productEvents.assertVersionsAreStrictlyIncreasing()

            val paymentEvents = MengoEventStoreAudit.fetchEvents(paymentPostgres, "payment", "payment_events")
            paymentEvents.assertHasEventType("Initiated")
            paymentEvents.assertHasEventType("Failed")
            paymentEvents.assertVersionsAreStrictlyIncreasing()
        }

        createKafkaClient().consumeAndAssert<BookingCancelledPayload>("booking.failed") { msg ->
            assertNotNull(msg, "Expected a record in booking.failed topic")
            assertEquals(response.bookingId.toString(), msg.key())
        }
    }

    private fun createBookingClient(headers: Map<String, String> = emptyMap()): BookingFeignClient {
        val url = "http://${bookingService.host}:${bookingService.getMappedPort(8080)}"

        val feignBuilder =
            Feign
                .builder()
                .encoder(JacksonEncoder())
                .decoder(JacksonDecoder())
                .contract(SpringMvcContract())

        if (headers.isNotEmpty()) {
            feignBuilder.requestInterceptor { template ->
                headers.forEach { (key, value) -> template.header(key, value) }
            }
        }

        return feignBuilder.target(BookingFeignClient::class.java, url)
    }
}
