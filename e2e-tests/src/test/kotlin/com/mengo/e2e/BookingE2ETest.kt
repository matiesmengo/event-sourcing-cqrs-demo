package com.mengo.e2e

import com.mengo.booking.model.BookingProduct
import com.mengo.booking.model.CreateBookingRequest
import com.mengo.e2e.clients.BookingFeignClient
import com.mengo.e2e.infrastructure.AbstractServicesE2ETest
import com.mengo.e2e.infrastructure.EventStoreFetch.fetchEventsFromPostgres
import com.mengo.e2e.infrastructure.KafkaTestConsumer
import feign.Feign
import feign.jackson.JacksonDecoder
import feign.jackson.JacksonEncoder
import org.awaitility.Awaitility.await
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.springframework.cloud.openfeign.support.SpringMvcContract
import java.time.Duration
import java.util.UUID
import kotlin.test.assertEquals
import kotlin.test.assertNotNull
import kotlin.test.assertTrue

class BookingE2ETest : AbstractServicesE2ETest() {
    // TODO: e2e errors

    @BeforeEach
    fun startContainers() {
        orchestratorService.start()
        bookingService.start()
        paymentService.start()
        productService.start()
    }

    @Test
    fun `booking to payment flow E2E`() {
        // given
        val bookingClient = createBookingClient()
        val productId = UUID.fromString("22222222-2222-2222-2222-222222222222")

        val createRequest =
            CreateBookingRequest()
                .userId(UUID.randomUUID())
                .products(
                    listOf(
                        BookingProduct()
                            .productId(productId)
                            .quantity(2),
                    ),
                )

        // when
        val response = bookingClient.bookingsPost(createRequest)

        assertNotNull(response, "Booking response should not be null")
        assertNotNull(response.bookingId, "Booking ID should be generated by the service")
        assertEquals("CREATED", response.status.toString(), "Booking should start in CREATED state")

        // then
        await().atMost(Duration.ofSeconds(30)).untilAsserted {
            // BookingService events (BookingCreatedEvent, BookingPaymentConfirmedEvent)
            val bookingEvents = fetchEventsFromPostgres(bookingPostgres, "booking", "booking_events")
            val bookingTypes = bookingEvents.map { it.type }

            assertTrue(
                bookingTypes.contains("BookingCreatedEvent"),
                "Expected BookingCreatedEvent in booking.booking_events",
            )
            assertTrue(
                bookingTypes.contains("BookingPaymentConfirmedEvent"),
                "Expected BookingPaymentConfirmedEvent in booking.booking_events",
            )
            assertTrue(
                bookingEvents.zipWithNext().all { it.first.aggregateVersion < it.second.aggregateVersion },
                "Aggregate versions in booking.booking_events must increase strictly",
            )

            // ProductService events (ProductReservedEvent)
            val productEvents = fetchEventsFromPostgres(productPostgres, "product", "product_events", productId)
            val productTypes = productEvents.map { it.type }

            assertTrue(
                productTypes.contains("ProductReservedEvent"),
                "Expected ProductReservedEvent in product.product_events for productId=$productId",
            )
            assertTrue(
                productEvents.zipWithNext().all { it.first.aggregateVersion < it.second.aggregateVersion },
                "Aggregate versions in product.events must increase strictly",
            )

            // PaymentService events (PaymentInitiatedEvent, PaymentCompletedEvent)
            val paymentEvents = fetchEventsFromPostgres(paymentPostgres, "payment", "payment_events")
            val paymentTypes = paymentEvents.map { it.type }

            assertTrue(
                paymentTypes.contains("PaymentInitiatedEvent"),
                "Expected PaymentInitiatedEvent in payment.payment_events",
            )
            assertTrue(
                paymentTypes.contains("PaymentCompletedEvent"),
                "Expected PaymentCompletedEvent in payment.payment_events",
            )
            assertTrue(
                paymentEvents.zipWithNext().all { it.first.aggregateVersion < it.second.aggregateVersion },
                "Aggregate versions in payment.events must increase strictly",
            )

            // BookingServiceOrchestrator events (PaymentInitiatedEvent, PaymentCompletedEvent)
            val orchestratorEvents =
                fetchEventsFromPostgres(orchestratorPostgres, "orchestrator", "orchestrator_events")
            val orchestratorTypes = orchestratorEvents.map { it.type }

            assertTrue(
                orchestratorTypes.contains("WaitingStock"),
                "Expected WaitingStock in orchestrator.orchestrator_events",
            )
            assertTrue(
                orchestratorTypes.contains("WaitingPayment"),
                "Expected WaitingPayment in orchestrator.orchestrator_events",
            )
            assertTrue(
                orchestratorTypes.contains("Completed"),
                "Expected Completed in orchestrator.orchestrator_events",
            )
            assertTrue(
                orchestratorEvents.zipWithNext().all { it.first.aggregateVersion < it.second.aggregateVersion },
                "Aggregate versions in orchestrator.events must increase strictly",
            )
        }

        // booking.completed topic
        KafkaTestConsumer(kafka.bootstrapServers).consumeAndAssert("booking.completed") { msg ->
            assertNotNull(msg, "Expected a record in booking.completed topic")
            assertEquals(response.bookingId.toString(), msg.key())
        }
    }

    private fun createBookingClient(): BookingFeignClient {
        val url = "http://${bookingService.host}:${bookingService.getMappedPort(8080)}"
        return Feign
            .builder()
            .encoder(JacksonEncoder())
            .decoder(JacksonDecoder())
            .contract(SpringMvcContract())
            .target(BookingFeignClient::class.java, url)
    }
}
